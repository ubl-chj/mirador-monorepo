import {
  Mosaic, MosaicWindow, createBalancedTreeFromLeaves, getLeaves,
} from 'react-mosaic-component';
import MosaicRenderPreview from '../../containers/workspace/MosaicRenderPreview';
import React from 'react';
import Window from '../../containers/window/Window';

interface IWorkspaceMosaic {
  updateWorkspaceMosaicLayout: any
  windows: any
  workspace: any
}
/**
 * Represents a work area that contains any number of windows
 * @memberof Workspace
 * @private
 */
export class WorkspaceMosaic extends React.Component<IWorkspaceMosaic> {
  private zeroStateView: any

  /**
   */
  public constructor(props) {
    super(props);

    this.tileRenderer = this.tileRenderer.bind(this);
    this.mosaicChange = this.mosaicChange.bind(this);
    this.determineWorkspaceLayout = this.determineWorkspaceLayout.bind(this);
    this.zeroStateView = <div />;
  }

  /** */
  public componentDidMount() {
    const { updateWorkspaceMosaicLayout } = this.props;
    const newLayout = this.determineWorkspaceLayout();
    if (newLayout) updateWorkspaceMosaicLayout(newLayout);
  }

  /** */
  public componentDidUpdate(prevProps) {
    const { workspace, updateWorkspaceMosaicLayout } = this.props;
    if (prevProps.workspace.layout !== workspace.layout) {
      const newLayout = this.determineWorkspaceLayout();
      if (newLayout !== workspace.layout) updateWorkspaceMosaicLayout(newLayout);
    }
  }

  /**
   * Used to determine whether or not a "new" layout should be autogenerated.
   * If a Window is added or removed, generate that new layout and use that for
   * this render. When the Mosaic changes, that will trigger a new store update.
   */
  private determineWorkspaceLayout() {
    const { windows, workspace } = this.props;
    const windowKeys = Object.keys(windows).sort();
    const leaveKeys = getLeaves(workspace.layout);
    // Check every window is in the layout, and all layout windows are present
    // in store
    if (!windowKeys.every(e => leaveKeys.includes(e))
    || !leaveKeys.every(e => windowKeys.includes(e))) {
      const newLayout = createBalancedTreeFromLeaves(windowKeys);
      return newLayout;
    }
    return workspace.layout;
  }

  /**
   * Render a tile (Window) in the Mosaic.
   */
  private tileRenderer(id, path) {
    const { windows } = this.props;
    const window = windows[id];
    if (!window) return null;

    return (
      <MosaicWindow
        additionalControls={[]}
        path={path}
        renderPreview={() => (
          <div className="mosaic-preview">
            <MosaicRenderPreview windowId={window.id} />
          </div>
        )}
        title={null}
        toolbarControls={[]}
      >
        <Window
          key={window.id}
          window={window}
        />
      </MosaicWindow>
    );
  }

  /**
   * Update the redux store when the Mosaic is changed.
   */
  private mosaicChange(newLayout) {
    const { updateWorkspaceMosaicLayout } = this.props;
    updateWorkspaceMosaicLayout(newLayout);
  }

  /**
   */
  public render() {
    const { workspace } = this.props;
    return (
      <Mosaic
        className="mirador-mosaic"
        initialValue={workspace.layout || this.determineWorkspaceLayout()}
        onChange={this.mosaicChange}
        renderTile={this.tileRenderer}
        zeroStateView={this.zeroStateView}
      />
    );
  }
}
